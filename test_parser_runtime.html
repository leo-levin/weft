<!DOCTYPE html>
<html>
<head>
  <title>Test Parser + Runtime</title>
  <script src="https://unpkg.com/ohm-js@16/dist/ohm.min.js"></script>
  <style>
    body { font-family: monospace; padding: 20px; }
    .test { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
    .pass { background: #d4edda; }
    .fail { background: #f8d7da; }
    pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Parser + Runtime Test Suite</h1>
  <div id="results"></div>

  <script type="module">
    import { parse } from './src/lang/parser-new.js';
    import { Env, Executor } from './src/runtime/runtime-new.js';

    const results = document.getElementById('results');

    function test(name, code, assertions) {
      const div = document.createElement('div');
      div.className = 'test';

      try {
        // Parse
        const ast = parse(code);

        // Execute
        const env = new Env();
        const executor = new Executor(env);
        executor.execute(ast);

        // Run assertions
        let allPassed = true;
        const assertionResults = [];

        for (const [desc, check] of Object.entries(assertions)) {
          try {
            const passed = check(env, ast);
            assertionResults.push(`${passed ? '[PASS]' : '[FAIL]'} ${desc}`);
            if (!passed) allPassed = false;
          } catch (e) {
            assertionResults.push(`[FAIL] ${desc}: ${e.message}`);
            allPassed = false;
          }
        }

        div.className += allPassed ? ' pass' : ' fail';
        div.innerHTML = `
          <h3>${allPassed ? '[PASS]' : '[FAIL]'} ${name}</h3>
          <pre>${code}</pre>
          <div>${assertionResults.join('<br>')}</div>
        `;
      } catch (e) {
        div.className += ' fail';
        div.innerHTML = `
          <h3>[ERROR] ${name}</h3>
          <pre>${code}</pre>
          <div style="color: red;">Error: ${e.message}</div>
          <pre>${e.stack}</pre>
        `;
      }

      results.appendChild(div);
    }

    // Test 1: Basic tilde syntax parsing
    test('Tilde Syntax - Simple Swap',
      `display(img@r(x ~ me@y, y ~ me@x))`,
      {
        'Parses without error': (env, ast) => true,
        'Has DisplayStmt': (env, ast) => ast.statements[0].type === 'DisplayStmt',
        'Has StrandRemap expr': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.type === 'StrandRemap';
        },
        'Has 2 axis mappings': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.mappings.length === 2;
        },
        'First mapping is x ~ me@y': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          const mapping = expr.mappings[0];
          return mapping.axis === 'x' && mapping.expr.type === 'Me' && mapping.expr.field === 'y';
        },
        'Second mapping is y ~ me@x': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          const mapping = expr.mappings[1];
          return mapping.axis === 'y' && mapping.expr.type === 'Me' && mapping.expr.field === 'x';
        }
      }
    );

    // Test 2: Spindle definition
    test('Spindle Definition',
      `spindle test(x, y) :: <out> {
        out = x + y
      }`,
      {
        'Parses without error': (env, ast) => true,
        'Has SpindleDef': (env, ast) => ast.statements[0].type === 'SpindleDef',
        'Spindle stored in env': (env, ast) => env.spindles.has('test'),
        'Spindle has 2 params': (env, ast) => {
          const spindle = env.spindles.get('test');
          return spindle.inputs.length === 2;
        },
        'Spindle has 1 output': (env, ast) => {
          const spindle = env.spindles.get('test');
          return spindle.outputs.length === 1;
        }
      }
    );

    // Test 3: Instance binding with single output
    test('Instance Binding - Single Output',
      `foo<x> = 5`,
      {
        'Parses without error': (env, ast) => true,
        'Instance stored in env': (env, ast) => env.instances.has('foo'),
        'Instance is type expr': (env, ast) => {
          const inst = env.instances.get('foo');
          return inst.type === 'expr';
        },
        'Instance has 1 output': (env, ast) => {
          const inst = env.instances.get('foo');
          return inst.outputs.length === 1 && inst.outputs[0] === 'x';
        },
        'Instance expr is Num with value 5': (env, ast) => {
          const inst = env.instances.get('foo');
          return inst.expr.type === 'Num' && inst.expr.v === 5;
        }
      }
    );

    // Test 4: Instance binding with call
    test('Instance Binding - Call',
      `load("test.jpg")::img<r,g,b>`,
      {
        'Parses without error': (env, ast) => true,
        'Instance stored in env': (env, ast) => env.instances.has('img'),
        'Instance is type call': (env, ast) => {
          const inst = env.instances.get('img');
          return inst.type === 'call';
        },
        'Instance calls load': (env, ast) => {
          const inst = env.instances.get('img');
          return inst.callName === 'load';
        },
        'Instance has 3 outputs': (env, ast) => {
          const inst = env.instances.get('img');
          return inst.outputs.length === 3;
        }
      }
    );

    // Test 5: Multiple instance bindings (proper WEFT)
    test('Multiple Instance Bindings',
      `color<r> = me@x
       color<g> = me@y
       color<b> = 0`,
      {
        'Parses without error': (env, ast) => true,
        'Has 3 statements': (env, ast) => ast.statements.length === 3,
        'color instance exists': (env, ast) => env.instances.has('color'),
        'All statements are InstanceBinding': (env, ast) => {
          return ast.statements.every(s => s.type === 'InstanceBinding');
        }
      }
    );

    // Test 6: Complex expression with tilde
    test('Complex Tilde Expression',
      `display(img@r(x ~ me@y + 0.5, y ~ me@x * 2, z ~ me@time))`,
      {
        'Parses without error': (env, ast) => true,
        'Has 3 axis mappings': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.mappings.length === 3;
        },
        'x mapping has binary expr': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.mappings[0].expr.type === 'Bin';
        },
        'y mapping has binary expr': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.mappings[1].expr.type === 'Bin';
        },
        'z mapping has Me expr': (env, ast) => {
          const expr = ast.statements[0].positionalArgs[0];
          return expr.mappings[2].expr.type === 'Me';
        }
      }
    );

    // Test 7: Built-in me instance
    test('Built-in me Instance',
      `display(me@x)`,
      {
        'Parses without error': (env, ast) => true,
        'me instance exists': (env, ast) => env.instances.has('me'),
        'me.x is a function': (env, ast) => {
          const me = env.instances.get('me');
          return typeof me.x === 'function';
        },
        'me.time is a function': (env, ast) => {
          const me = env.instances.get('me');
          return typeof me.time === 'function';
        }
      }
    );

    // Test 8: Let binding inside spindle block
    test('Let Binding in Spindle Block',
      `spindle test(a, b)::<out> {
        let x = a + b
        out = x * 2
      }`,
      {
        'Parses without error': (env, ast) => true,
        'Has SpindleDef': (env, ast) => ast.statements[0].type === 'SpindleDef',
        'Spindle stored in env': (env, ast) => env.spindles.has('test'),
        'Block has 2 statements': (env, ast) => {
          const spindle = env.spindles.get('test');
          return spindle.body.body.length === 2;
        },
        'First statement is LetBinding': (env, ast) => {
          const spindle = env.spindles.get('test');
          return spindle.body.body[0].type === 'LetBinding';
        }
      }
    );

    // === NEGATIVE TESTS ===

    function testError(name, code, expectedError) {
      const div = document.createElement('div');
      div.className = 'test';

      try {
        const ast = parse(code);
        // If we get here, parsing succeeded when it should have failed
        div.className += ' fail';
        div.innerHTML = `
          <h3>[FAIL] ${name}</h3>
          <pre>${code}</pre>
          <div style="color: red;">Expected parse error but parsing succeeded!</div>
        `;
      } catch (e) {
        // Parse error occurred as expected
        const matchesExpected = expectedError ? e.message.includes(expectedError) : true;
        div.className += matchesExpected ? ' pass' : ' fail';
        div.innerHTML = `
          <h3>${matchesExpected ? '[PASS]' : '[FAIL]'} ${name}</h3>
          <pre>${code}</pre>
          <div>Error (as expected): ${e.message}</div>
          ${!matchesExpected ? `<div style="color: red;">Expected error containing: ${expectedError}</div>` : ''}
        `;
      }

      results.appendChild(div);
    }

    // Test 9: Top-level let binding should fail
    testError('Reject Top-Level Let Binding',
      `let x = 5`,
      null  // Just needs to fail
    );

    // Test 10: Instance without output spec should fail
    testError('Reject Instance Without Output Spec',
      `foo = 5`,
      null
    );

    // Test 11: Missing closing brace
    testError('Reject Missing Closing Brace',
      `spindle test()::<out> {
        out = 5`,
      null
    );

    // Test 12: Invalid tilde syntax (missing axis name)
    testError('Reject Invalid Tilde Syntax',
      `display(img@r(~ me@x))`,
      null
    );

    // Test 13: Using reserved keyword as identifier
    testError('Reject Reserved Keyword as Identifier',
      `spindle<x> = 5`,
      null
    );

    console.log('All tests completed!');
  </script>
</body>
</html>
